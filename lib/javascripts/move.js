// Generated by CoffeeScript 1.6.2
var capture_stones_with, create_pass_move, create_stone, has_liberties, is_eye, is_pass_move, is_same_move, is_valid_move, other_color, play_stone;

create_stone = function(x, y, color) {
  return {
    x: x,
    y: y,
    color: color
  };
};

create_pass_move = function(color) {
  return create_stone(null, null, color);
};

play_stone = function(stone, board) {
  var captures;

  if (is_valid_move(stone, board)) {
    set_move(stone, board);
    captures = capture_stones_with(stone, board);
    stone.captures = captures;
    return board.moves.push(stone);
  } else {
    throw "Illegal move Exception!";
  }
};

is_pass_move = function(stone) {
  return (stone.x === null) || (stone.y === null);
};

other_color = function(color) {
  if (color === BLACK) {
    return WHITE;
  } else {
    return BLACK;
  }
};

has_liberties = function(stone, board) {
  var is_liberty, is_visited, search_for_liberties, visit, visited_map;

  is_visited = function(stone, visited_mapping) {
    return get_color(stone.x, stone.y, visited_mapping) === VISITED;
  };
  visit = function(stone, visited_mapping) {
    var visited_move;

    visited_move = create_stone(stone.x, stone.y, VISITED);
    return set_move(visited_move, visited_mapping);
  };
  is_liberty = function(stone, board, visited_map, color) {
    switch (stone.color) {
      case EMPTY:
        return true;
      case NEUTRAL:
        return false;
      case other_color(color):
        return false;
      case color:
        return search_for_liberties(stone.x, stone.y, board, visited_map, color);
      default:
        throw 'we should never end up here when checking for liberties';
    }
  };
  search_for_liberties = function(x, y, board, visited_map, color) {
    var neighbours, unvisited_neighbours;

    neighbours = neighbouring_stones(x, y, board);
    unvisited_neighbours = _.reject(neighbours, function(stone) {
      return is_visited(stone, visited_map);
    });
    _.each(unvisited_neighbours, function(stone) {
      return visit(stone, visited_map);
    });
    return _.any(unvisited_neighbours, function(stone) {
      return is_liberty(stone, board, visited_map, color);
    });
  };
  visited_map = initBoard(board.length);
  visit(stone, visited_map);
  return search_for_liberties(stone.x, stone.y, board, visited_map, stone.color);
};

is_valid_move = function(stone, board) {
  var field_is_unoccupied, is_capturing_stones, is_no_double_move, is_no_illegal_ko_move, is_no_suicide_move;

  field_is_unoccupied = function(stone, board) {
    return get_color(stone.x, stone.y, board) === EMPTY;
  };
  is_no_double_move = function(move, board) {
    if (board.moves.length === 0) {
      return true;
    } else {
      return get_last_move(board).color !== move.color;
    }
  };
  is_no_suicide_move = function(move, board) {
    return has_liberties(move, board) || is_capturing_stones(move, board);
  };
  is_capturing_stones = function(move, board) {
    var copied_board, neighbours;

    copied_board = copy_board(board);
    set_move(move, copied_board);
    neighbours = enemy_neighbours(move, copied_board);
    return !_.every(neighbours, function(stone) {
      return has_liberties(stone, copied_board);
    });
  };
  is_no_illegal_ko_move = function(move, board, captures) {
    var captures_of_move, is_first_move, last_move, last_move_and_current_move_captured_exactly_one;

    last_move_and_current_move_captured_exactly_one = function(captures, last_move) {
      return captures.length === 1 && last_move.captures.length === 1;
    };
    is_first_move = function(board) {
      return board.moves.length === 0;
    };
    captures_of_move = function(move, board) {
      var copied_board;

      copied_board = copy_board(board);
      set_move(stone, copied_board);
      return capture_stones_with(stone, copied_board);
    };
    if (is_first_move(board)) {
      return true;
    }
    last_move = get_last_move(board);
    captures = captures_of_move(stone, board);
    return !(last_move_and_current_move_captured_exactly_one(captures, last_move) && is_same_move(last_move.captures[0], move));
  };
  return is_no_double_move(stone, board) && (is_pass_move(stone) || (field_is_unoccupied(stone, board) && is_no_suicide_move(stone, board) && is_no_illegal_ko_move(stone, board)));
};

is_same_move = function(move, other_move) {
  return move.x === other_move.x && move.y === other_move.y && move.color === other_move.color;
};

capture_stones_with = function(stone, board) {
  var captures, enemy_color, increase_prisoner_count, remove_stone, take_captures;

  take_captures = function(stone, board, captive_color, captures) {
    var neighbours;

    if (captures == null) {
      captures = [];
    }
    if (stone.color === captive_color) {
      remove_stone(stone, board);
      increase_prisoner_count(board, captive_color);
      captures.push(stone);
      neighbours = neighbouring_stones(stone.x, stone.y, board);
      _.each(neighbours, function(stone) {
        return take_captures(stone, board, captive_color, captures);
      });
      return captures;
    }
  };
  remove_stone = function(stone, board) {
    var empty_move;

    empty_move = create_stone(stone.x, stone.y, EMPTY);
    return set_move(empty_move, board);
  };
  increase_prisoner_count = function(board, captive_color) {
    var own_color;

    own_color = other_color(captive_color);
    return board.prisoners[own_color] += 1;
  };
  enemy_color = other_color(stone.color);
  captures = [];
  if (!is_pass_move(stone)) {
    _.each(enemy_neighbours(stone, board), function(stone) {
      if (!has_liberties(stone, board)) {
        return captures = captures.concat(take_captures(stone, board, enemy_color));
      }
    });
  }
  return captures;
};

is_eye = function(move, board) {
  var diagonal_stone_colors, get_enemy_diagonals_count, is_edge_move, is_eye_shape, is_real_eye;

  is_eye_shape = function(move, board) {
    var neighbours;

    neighbours = neighbouring_stones(move.x, move.y, board);
    return _.all(neighbours, function(neighbour) {
      return neighbour.color === move.color || neighbour.color === NEUTRAL;
    });
  };
  diagonal_stone_colors = function(move, board) {
    var x, y;

    x = move.x;
    y = move.y;
    return [get_color(x + 1, y + 1, board), get_color(x + 1, y - 1, board), get_color(x - 1, y + 1, board), get_color(x - 1, y - 1, board)];
  };
  is_edge_move = function(move, board) {
    return move.x === 0 || move.y === 0 || move.x === (board.length - 1) || move.y === (board.length - 1);
  };
  get_enemy_diagonals_count = function(move, board) {
    var diagonal_stones, opponent_color;

    diagonal_stones = diagonal_stone_colors(move, board);
    opponent_color = other_color(move.color);
    return _.select(diagonal_stones, function(color) {
      return color === opponent_color;
    }).length;
  };
  is_real_eye = function(move, board) {
    var enemy_diagonals_count;

    enemy_diagonals_count = get_enemy_diagonals_count(move, board);
    return enemy_diagonals_count === 0 || (!is_edge_move(move, board) && enemy_diagonals_count < 2);
  };
  if (is_pass_move(move)) {
    return false;
  } else {
    return is_eye_shape(move, board) && is_real_eye(move, board);
  }
};
