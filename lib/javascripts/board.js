// Generated by CoffeeScript 1.6.2
var BACK_MAPPING, BLACK, EMPTY, NEUTRAL, SIGN_MAPPING, VISITED, WHITE, all_fields_do, board_from_string, copy_board, enemy_neighbours, get_color, get_last_move, get_stone, initBoard, is_empty, is_equal_board, is_out_of_bounds, neighbouring_stones, print_board, set_move, set_stone;

BLACK = 1;

WHITE = -1;

EMPTY = 0;

NEUTRAL = 2;

VISITED = true;

initBoard = function(size) {
  var board, i, j, _i, _j;

  board = [];
  for (i = _i = 0; 0 <= size ? _i < size : _i > size; i = 0 <= size ? ++_i : --_i) {
    board.push([]);
    for (j = _j = 0; 0 <= size ? _j < size : _j > size; j = 0 <= size ? ++_j : --_j) {
      board[i][j] = EMPTY;
    }
  }
  board.moves = [];
  board.prisoners = {};
  board.prisoners[BLACK] = 0;
  board.prisoners[WHITE] = 0;
  return board;
};

copy_board = function(board) {
  var copy, copy_prisoners, deep_copy_2_dimensional_array;

  deep_copy_2_dimensional_array = function(array) {
    var copy, i, _i, _ref;

    copy = [];
    for (i = _i = 0, _ref = array.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      copy.push(array[i].slice(0));
    }
    return copy;
  };
  copy_prisoners = function(prisoners) {
    var copied_prisoners;

    copied_prisoners = {};
    copied_prisoners[BLACK] = prisoners[BLACK];
    copied_prisoners[WHITE] = prisoners[WHITE];
    return copied_prisoners;
  };
  copy = deep_copy_2_dimensional_array(board);
  copy.moves = board.moves.slice(0);
  copy.prisoners = copy_prisoners(board.prisoners);
  return copy;
};

set_move = function(move, board) {
  if (!(is_pass_move(move) || is_out_of_bounds(move.x, move.y, board))) {
    return set_stone(move, board);
  }
};

set_stone = function(stone, board) {
  return board[stone.y][stone.x] = stone.color;
};

is_empty = function(collection) {
  return collection.length === 0;
};

is_out_of_bounds = function(x, y, board) {
  var board_size;

  board_size = board.length;
  if ((x < 0) || (y < 0) || (x >= board_size) || (y >= board_size)) {
    return true;
  } else {
    return false;
  }
};

get_color = function(x, y, board) {
  if (is_out_of_bounds(x, y, board)) {
    return NEUTRAL;
  } else {
    return board[y][x];
  }
};

get_stone = function(x, y, board) {
  return {
    x: x,
    y: y,
    color: get_color(x, y, board)
  };
};

neighbouring_stones = function(x, y, board) {
  return [get_stone(x, y - 1, board), get_stone(x, y + 1, board), get_stone(x - 1, y, board), get_stone(x + 1, y, board)];
};

enemy_neighbours = function(my_stone, board) {
  var enemy_color, neighbours;

  neighbours = neighbouring_stones(my_stone.x, my_stone.y, board);
  enemy_color = other_color(my_stone.color);
  return _.select(neighbours, function(neighbouring_stone) {
    return neighbouring_stone.color === enemy_color;
  });
};

is_equal_board = function(board_1, board_2) {
  return '' + board_1 === '' + board_2;
};

get_last_move = function(board) {
  if (board.moves.length >= 1) {
    return board.moves[board.moves.length - 1];
  } else {
    return null;
  }
};

all_fields_do = function(board, func) {
  var x, y, _i, _ref, _results;

  _results = [];
  for (y = _i = 0, _ref = board.length; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
    _results.push((function() {
      var _j, _ref1, _results1;

      _results1 = [];
      for (x = _j = 0, _ref1 = board.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
        _results1.push(func(x, y, get_color(x, y, board)));
      }
      return _results1;
    })());
  }
  return _results;
};

SIGN_MAPPING = {};

SIGN_MAPPING[BLACK] = "X";

SIGN_MAPPING[WHITE] = "O";

SIGN_MAPPING[EMPTY] = "-";

BACK_MAPPING = {};

BACK_MAPPING["X"] = BLACK;

BACK_MAPPING["O"] = WHITE;

BACK_MAPPING["-"] = EMPTY;

print_board = function(board) {
  var result, sign_for_color, x, y, _i, _j, _ref, _ref1;

  sign_for_color = function(color) {
    return SIGN_MAPPING[color];
  };
  result = "";
  for (y = _i = 0, _ref = board.length; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
    for (x = _j = 0, _ref1 = board.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
      result += sign_for_color(get_color(x, y, board));
    }
    result += "\n";
  }
  return result.slice(0, -1);
};

board_from_string = function(string) {
  var board, board_size, color_for_sign, lines, x, y, _i, _j;

  color_for_sign = function(sign) {
    return BACK_MAPPING[sign];
  };
  lines = string.split("\n");
  board_size = lines.length;
  board = initBoard(board_size);
  for (y = _i = 0; 0 <= board_size ? _i < board_size : _i > board_size; y = 0 <= board_size ? ++_i : --_i) {
    for (x = _j = 0; 0 <= board_size ? _j < board_size : _j > board_size; x = 0 <= board_size ? ++_j : --_j) {
      set_move(create_stone(x, y, color_for_sign(lines[y][x])), board);
    }
  }
  return board;
};
