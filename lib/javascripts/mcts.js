// Generated by CoffeeScript 1.6.2
var DEFAULt_PLAYOUTS, UCT_BIAS_FACTOR, backpropagate, create_node, create_root, expand, is_end_of_tree, mcts, rollout, select, select_best_node, uct_select_child, uct_value_for;

UCT_BIAS_FACTOR = 2;

DEFAULt_PLAYOUTS = 100;

create_node = function(board, move, parent) {
  var node;

  node = {
    move: move,
    board: board,
    parent: parent,
    wins: 0,
    visits: 0,
    children: [],
    untried_moves: get_all_plausible_moves(board)
  };
  return node;
};

create_root = function(board) {
  var root;

  return root = create_node(board, null, null);
};

select = function(root) {
  var selected_node;

  selected_node = root;
  while (selected_node.untried_moves.length <= 0) {
    selected_node = uct_select_child(selected_node);
  }
  return selected_node;
};

uct_value_for = function(node) {
  return node.wins / node.visits + UCT_BIAS_FACTOR * Math.sqrt(Math.log(node.parent.visits) / node.visits);
};

uct_select_child = function(node) {
  var max_node, max_value;

  max_value = 0;
  max_node = null;
  _.each(node.children, function(child) {
    var new_value;

    new_value = uct_value_for(child);
    if (new_value > max_value) {
      max_node = child;
      return max_value = new_value;
    }
  });
  return max_node;
};

expand = function(node) {
  var create_child_node, move;

  create_child_node = function(parent, move) {
    var board, child;

    board = copy_board(parent.board);
    play_stone(move, board);
    child = create_node(board, move, parent);
    parent.children.push(child);
    return child;
  };
  move = node.untried_moves.pop();
  return create_child_node(node, move);
};

rollout = function(node, own_color) {
  var finished_board, playout_board;

  playout_board = copy_board(node.board);
  finished_board = playout_for_board(playout_board);
  return score_game(finished_board).winner === own_color;
};

is_end_of_tree = function(node) {
  return node === null;
};

backpropagate = function(node, have_won) {
  var win_modifier, _results;

  if (have_won) {
    win_modifier = 1;
  } else {
    win_modifier = 0;
  }
  _results = [];
  while (!is_end_of_tree(node)) {
    node.visits += 1;
    node.wins += win_modifier;
    _results.push(node = node.parent);
  }
  return _results;
};

select_best_node = function(node) {
  var best_node, best_win_average;

  best_node = null;
  best_win_average = 0;
  _.each(node.children, function(child) {
    var win_average;

    win_average = child.wins / child.visits;
    if (win_average >= best_win_average) {
      best_win_average = win_average;
      return best_node = child;
    }
  });
  return best_node;
};

mcts = function(board, playouts) {
  var best_node, explore_tree, i, own_color, root, _i;

  if (playouts == null) {
    playouts = DEFAULt_PLAYOUTS;
  }
  explore_tree = function(root, own_color) {
    var have_won, new_child, selected_node;

    selected_node = select(root);
    new_child = expand(selected_node);
    have_won = rollout(new_child, own_color);
    return backpropagate(new_child, have_won);
  };
  root = create_root(board);
  own_color = determine_move_color(board);
  for (i = _i = 0; 0 <= playouts ? _i < playouts : _i > playouts; i = 0 <= playouts ? ++_i : --_i) {
    explore_tree(root, own_color);
  }
  best_node = select_best_node(root);
  return best_node.move;
};
